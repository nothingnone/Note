<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-99698725-e524-4d42-aee0-f3d1a919326e"></attachment><ul><li>大小端。一个int 0x12345678，四个字节。倘若大端，则大端在前，低地址保存高字节，0x12 34 56 78，通讯多采用该方法。而小端相反，为0x78 56 34 12，优点在与便于转换，一般都是小端。</li><li>shared pointer 实现</li></ul><pre class="ql-syntax" spellcheck="false">template &lt;typename T&gt;
class shared_point;

template &lt;typename T&gt;
class assit_p
{
private:
&nbsp; &nbsp; friend class shared_point&lt;T&gt;;&nbsp; &nbsp;
&nbsp; &nbsp; assit_p(T* ptr)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; :p(ptr)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; &nbsp; &nbsp; ,count(1)
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; *p &lt;&lt;"\tnew"&lt;&lt; std::endl;
&nbsp; &nbsp; }
&nbsp; &nbsp; ~assit_p()
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; *p &lt;&lt;"\tdelete"&lt;&lt; std::endl;
&nbsp; &nbsp; &nbsp; &nbsp; delete p;
&nbsp; &nbsp; }
&nbsp; &nbsp; T *p;
&nbsp; &nbsp; int count;
};

template &lt;typename T&gt;
class shared_point
{
public:
&nbsp; &nbsp; shared_point(T* ptr)
&nbsp; &nbsp; &nbsp; &nbsp; :p(new assit_p&lt;T&gt;(ptr))
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; //&nbsp;
&nbsp; &nbsp; }
&nbsp; &nbsp; shared_point(const shared_point&lt;T&gt; &amp;sptr)
&nbsp; &nbsp; &nbsp; &nbsp; :p(sptr.p)&nbsp; //attention! this use private member
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; ++p-&gt;count;
&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; *(p-&gt;p)&lt;&lt;"\tadd,now\t"&lt;&lt;p-&gt;count&lt;&lt; std::endl;
&nbsp; &nbsp; }
&nbsp; &nbsp; // = operator return operated result ref
&nbsp; &nbsp; shared_point&amp; operator=(const shared_point&lt;T&gt; &amp;sptr)
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; ++sptr.p-&gt;count;
&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; *(sptr.p-&gt;p)&lt;&lt;"\tadd,now\t"&lt;&lt;sptr.p-&gt;count&lt;&lt; std::endl;
&nbsp; &nbsp; &nbsp; &nbsp; if(0 == --p-&gt;count)
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete p;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; p = sptr.p;
&nbsp; &nbsp; &nbsp; &nbsp; return *this;
&nbsp; &nbsp; }
&nbsp; &nbsp; ~shared_point()
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; if(0 == -- p-&gt;count)
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delete p;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; else
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; *(p-&gt;p)&lt;&lt;"\tminus,now\t"&lt;&lt;p-&gt;count&lt;&lt; std::endl;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
private:
&nbsp; &nbsp; assit_p&lt;T&gt;* p;&nbsp;
};

int main()
{
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; shared_point&lt;double&gt; ptr1(new double(3.1415926));
&nbsp; &nbsp; &nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shared_point&lt;double&gt; ptr2(ptr1);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shared_point&lt;double&gt; ptr3(new double(6.28));
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr3 = ptr2;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; return 0;
}
</pre><ul><li>由其实现有以下注意：</li><li class="ql-indent-1">用make<em>shared构造对象并令sharedptr指向它。一旦构造出智能指针，指针的转移可以看做时所有权的移交、分享。不要用原指针指向、构造shared</em>ptr，尤其注意不要把指向栈的指针赋给<em>shared_</em>ptr。<em>shared_</em>ptr的使用规范为，当需要创建对象并分享、移交控制权时，用make_shared创建、初始化<em>shared_</em>ptr，后续对该对象的所有指针操作均用<em>shared_</em>ptr完成，注意与常指针的隔离。</li><li class="ql-indent-1">编写的程序为简单实现，并不保证线程安全。通过采用辅助类的方式保存引用信息，多个智能指针共享该对象，内部的操作存在危险，因为++i非院子操作，寄存器不及时将值写回，编译器优化，cou指令调度等。</li><li><br></li></ul><p><br></p>