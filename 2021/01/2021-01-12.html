<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-a5aa438d-2e37-4257-a15f-ef216b3501c3"></attachment><ul><li>多线程程序</li><li class="ql-indent-1">线程安全：同步问题：多个线程要对某内存进行读写。不可重入程序的调用。</li><li class="ql-indent-1">多线程程序实际情况复杂，本笔记作增量shift记录。</li><li class="ql-indent-1">基本概念：多线程，同一数据，读取，计算，写入。</li><li class="ql-indent-1">倘若没有写入，且copy成本不大，选择copy。</li><li class="ql-indent-2">倘若copy成本较大，则需权衡copy和计算的成本，选择copy后计算或加读锁计算释放；前者主要消耗在于内存，copy成本（copy时必须加读锁，可通过结构体和copy构造函数加快读写速度），copy后资源立即释放。后者加锁，无需copy，计算后释放资源。</li><li class="ql-indent-2">倘若数据极大，无法copy，则采取读写锁的方式。此时，想办法采用局部加锁，局部更新的方式，避免占用。</li><li class="ql-indent-2">此时，读取操作几乎对性能无影响。核心在于减少外部数据更新的影响。</li><li class="ql-indent-1">若读取，写入占同小，计算占用较大。</li><li class="ql-indent-2">可采取计算队列模式，保证绝对同步性。同时根据队列压力，限制请求数量。计算可采取并行方式。</li><li class="ql-indent-1">若三者占同均较小，请求频率极高。</li><li class="ql-indent-2">Compare and Swap。读取数据，计算，再读取数据，确保数据没有被修改，再写入。否则循环。存在ABA问题。</li><li class="ql-indent-2">更新队列措施，很好。</li><li class="ql-indent-1">若读取，写入分离的程序。使用缓存方式。</li><li class="ql-indent-2">一般采取措施是采用读写锁，能够保证同步性。性能限制在于更新程序时，读取必定无法响应。倘若对数据同步性没有过分要求，可采取双线结构，保存两个数据对象，当更新数据时，指针指向备用数据，更新完毕后切换。</li><li class="ql-indent-1">锁阻塞与非阻塞式同步策略。阻塞式安全性高，而非阻塞式能够有效避免锁的争用，但实现复杂。</li><li class="ql-indent-1">优先级锁。</li><li class="ql-indent-1">死锁问题，在逻辑上，代码中存在循环更新逻辑。在代码上，线程crash，而资源没有释放。性能下降，导致程序的同步逻辑变化所出现的问题。</li><li class="ql-indent-1">性能影响：锁的争用，同步损耗，</li><li class="ql-indent-1">策略与方法：退化策略；线程解耦；非阻塞锁（复杂）；更新队列；绝对退化概率（忍错）；</li><li class="ql-indent-1">性能问题。</li><li>Boost 多线程库</li></ul><p><br></p>