<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-6a775984-a4ce-4b0a-9320-b70e6728acfa"></attachment><ul><li>传递函数时，注意不要把消失的栈地址或者引用传递出去了。</li><li>将程序看做堆栈操作。</li><li>将编译看做符号操作。</li><li>引用的存在是为了安全考虑，引用同样会创建内存对象。由于引用的限制，其效率更高，不必检测其值是否为空，不必进行类型检测。</li><li>注意，对于一些对内存有操作性的函数，尽可能保证其安全！对于计算型和取值型，不会导致程序的crash，但写入操作会！</li><li>由于指针初始化的问题，一定要检查新建对象指针是否为空</li><li>指针与引用</li><li class="ql-indent-1">指针创建两个对象，指针与指针值。指针固定，而指针值可变。</li><li class="ql-indent-1">指针的初始化必须使用地址，而引用的初始化不必。引用是符号，引用的地址为引用对象的地址，而指针的地址为</li><li class="ql-indent-1">当采用指针和引用想</li><li class="ql-indent-1">指向常量的常指针 int const <em> const p = </em>addr(&amp;v,new v, malloc a), const<em> </em>int * const p = addr.</li><li class="ql-indent-1">typedef 问题，typedef string* pstring; string s; const pstring p1 = &amp;s; X pstring const p2 = &amp;s; yes 前者声明了一个常量指针，指向了指针，那么指针的值无法变动。后者声明了常指针指向指针地址，指针的值可以变动但地址不会变动。注意地址的嵌套问题!</li><li class="ql-indent-1">操作符重载的问题</li></ul><p><br></p>