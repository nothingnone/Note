<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-0ab1c70a-29a2-425e-b75c-d224f2e61f82"></attachment><ul><li>右值引用仅适用于局部变量！</li><li>右值引用影响对象生命周期？左值引用不影响生命周期，右值引用的实现？</li><li>注意右值引用与move构造的区别，不要混淆概念！构造函数在接受参数时存在引用折叠问题。</li></ul><pre class="ql-syntax" spellcheck="false">
</pre><ul><li>哪些对象默认实现了move构造函数？容器</li><li>move构造函数实现（内部可以直接存变量而不是保存引用或指针？？传进来的参数是右值引用，而后用右值引用构造一个对象？）</li><li class="ql-indent-1">移动构造函数详解</li><li class="ql-indent-1">return 语句：拷贝</li><li class="ql-indent-1">attention！当对象存在指针成员，则深拷贝该对象。同样，对于使用=/()拷贝指针时，必定是深拷贝，同时拷贝指针和指针指向的地址（避免析构时对该对象释放多次），同时避免对指针的应用（对于shared_ptr，这会影响内存的管理！要指向某个对象，就直接指向/或间接指向所有者,保证所有关系清晰!）。</li><li>对左值使用move浅拷贝和引用的区别？？不能将左值赋给右值，反之亦然，那又为什么要搞一个move函数强行将左值转换为右值。</li><li>一般情况下，在不使用shared_ptr的情况下，</li><li>std::move强制类型转换的原理实现</li><li>完美转发 std::forward 。针对模版编程，原理与应用！</li><li>右值引用的关键在于减少一次拷贝函数？？</li><li>对象=号调用copy构造函数还是默认构造函数？=右边是右值还是左值？</li><li>纯右值，将亡值（和右值引用相关的表达式）。</li><li>编译器的拷贝优化。可以在构造函数和拷贝函数中添加语句观察调用顺序。</li></ul><p><br></p><ul><li>for（auto i : char[]/{}/container）注意，对于容器i为元素引用而非迭代器指针。对于部分容器，暴露引用不要更改其值，避免发生未定义行为。修改值要使用容器接口！</li></ul><p><br></p>