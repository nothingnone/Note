<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-0ab1c70a-29a2-425e-b75c-d224f2e61f82"></attachment><ul><li>右值引用仅适用于局部变量！不能将右值引用指向左值，不能将左值引用指向右值。</li><li>右值引用影响对象生命周期？左值引用不影响生命周期，右值引用的实现？</li><li>注意右值引用与move构造的区别，不要混淆概念！构造函数在接受参数时存在引用折叠问题。</li></ul><pre class="ql-syntax" spellcheck="false">
</pre><ul><li>哪些对象默认实现了move构造函数？容器</li><li>move构造函数实现（内部可以直接存变量而不是保存引用或指针？？传进来的参数是右值引用，而后用右值引用构造一个对象？）</li><li class="ql-indent-1">移动构造函数详解</li><li class="ql-indent-1">return 语句：拷贝</li><li class="ql-indent-1">attention！当对象存在指针成员，则深拷贝该对象。同样，对于使用=/()拷贝指针时，必定是深拷贝，同时拷贝指针和指针指向的地址（避免析构时对该对象释放多次），同时避免对指针的应用（对于shared_ptr，这会影响内存的管理！要指向某个对象，就直接指向/或间接指向所有者,保证所有关系清晰!）。</li><li>对左值使用move浅拷贝和引用的区别？？不能将左值赋给右值，反之亦然，那又为什么要搞一个move函数强行将左值转换为右值。</li><li>一般情况下，在不使用shared_ptr的情况下，倘若一个类私有指针对象，则必须在析构函数中释放。倘若对该值copy，则必须copy指针指向的对象。对于该类所有的类成员，递归式深拷贝所有指针。若A a = getA()对右值进行move构造，则浅拷贝右值的所有成员（此时A已分配地址），将自身指针指向右值，并将右值指针指向A。语句执行结束后，临时变量析构并释放A指针指向的内存。</li><li class="ql-indent-1">在函数的栈内存分配时，会将返回对象优先分配在栈低处，则当函数执行完毕是栈指针回调到返回对象后，同时相当于在栈上分配了内存。同时若为右值赋值，则将返回值地址赋值。（若赋值对象已分配内存？则copy？）</li><li>std::move强制类型转换的原理实现</li><li>完美转发 std::forward 。针对模版编程，原理与应用！</li><li>右值引用的关键在于减少一次拷贝函数？？</li><li>对象=号调用copy构造函数还是默认构造函数？=右边是右值还是左值？</li><li>纯右值，将亡值（和右值引用相关的表达式）。</li><li>编译器的拷贝优化。可以在构造函数和拷贝函数中添加语句观察调用顺序。</li></ul><p><br></p><ul><li>for（auto i : char[]/{}/container）注意，对于容器i为元素引用而非迭代器指针。对于部分容器，暴露引用不要更改其值，避免发生未定义行为。修改值要使用容器接口！</li><li>tips</li><li class="ql-indent-1">右值构造中，A a=getA(); 是将右值的所有成员copy？只对指针move？</li><li class="ql-indent-1">右值构造函数与构造函数中（本身就是为了copy，不可能是copy一份作为参数传入构造函数中），传入的是参数是引用！</li><li class="ql-indent-1">传入形参，若为对象，调用参数为对象，在本地构造局部对象并copy！若为引用，调用参数为对象，则函数域中任何对引用的操作都会被间接寻址。（引用是对象，引用没有地址，对引用的所有操作都会被间接寻址）。若形参为指针，则调用参数为地址或指针，在作用域内生成指针对象。对于右值引用，同引用，但注意右值引用本身是左值！对其操作将被间接寻址到临时变量！</li><li class="ql-indent-1">参数重载中无法区别传入的参数是对象还是引用。（正是由于引用是由参数名初始化而非是参数地址初始化（为了区分指针和引用））。</li><li class="ql-indent-1">能否将</li><li class="ql-indent-1">引用是否为对象？不是对象，其虽然能够在类中在构造时/函数形参传入被灵活指向，但其总是在构造时初始化。本质？难道是对符号表的操作？倘若一个函数被重入，符号又如何安排？</li></ul><p><br></p>