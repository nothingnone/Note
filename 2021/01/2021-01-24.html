<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-0ab1c70a-29a2-425e-b75c-d224f2e61f82"></attachment><ul><li>右值引用仅适用于局部变量！不能将右值引用指向左值，不能将左值引用指向右值。</li><li>右值引用影响对象生命周期？左值引用不影响生命周期，右值引用的实现？当进入函数体时，函数内部的变量、局部变量等分配内存在函数栈栈桢上，因此右值引用指向的是局部变量地址、临时变量地址。同时，指向对象具备生命周期，当出局部时自动析构！</li><li>注意右值引用与move构造的区别，不要混淆概念！构造函数在接受参数时存在引用折叠。</li></ul><pre class="ql-syntax" spellcheck="false">
</pre><ul><li>哪些对象默认实现了move构造函数？容器</li><li>move构造函数实现（内部可以直接存变量而不是保存引用或指针？？传进来的参数是右值引用，而后用右值引用构造一个对象？）</li><li class="ql-indent-1">移动构造函数详解</li><li class="ql-indent-1">return 语句：拷贝</li><li class="ql-indent-1">attention！当对象存在指针成员，则深拷贝该对象。同样，对于使用=/()拷贝指针时，必定是深拷贝，同时拷贝指针和指针指向的地址（避免析构时对该对象释放多次），同时避免对指针的应用（对于shared_ptr，这会影响内存的管理！要指向某个对象，就直接指向/或间接指向所有者,保证所有关系清晰!）。</li><li>对左值使用move浅拷贝和引用的区别？？不能将左值赋给右值，反之亦然，那又为什么要搞一个move函数强行将左值转换为右值。</li><li>move构造函数：一般情况下，在不使用shared_ptr的情况下，倘若一个类私有指针对象，则必须在析构函数中释放。倘若对该值copy，则必须copy指针指向的对象。对于该类所有的类成员，递归式深拷贝所有指针。若对右值进行move构造，则浅拷贝右值的所有成员（此时A已分配地址），将自身指针指向右值，并将右值指针指向A。语句执行结束后，临时变量析构并释放A指针指向的内存。</li><li>std::move强制类型转换的原理实现</li><li>完美转发 std::forward 。针对模版编程，原理与应用！</li><li>构造，与赋值。</li><li class="ql-indent-1">A a()或A()调用的是构造函数。=调用=赋值函数（注意去看默认=函数的实现）。a()调用()操作符！</li><li class="ql-indent-1">构造函数以默认构造函数为准！构造函数参数 A&amp; A&amp;&amp; const A&amp;，倘若使用右值，只能调用后面两个初始化！究竟以哪一个为准需要进一步研究！</li><li class="ql-indent-1">当编写了move构造函数，则a=b（左值）会报错，必须重载运算符！</li><li class="ql-indent-1">当=右边是同类左值时，调用 T&amp; =(const T&amp;)。</li><li>纯右值，将亡值（和右值引用相关的表达式）。</li><li>编译器的拷贝优化。可以在构造函数和拷贝函数中添加语句观察调用顺序。</li></ul><p><br></p><ul><li>for（auto i : char[]/{}/container）注意，对于容器i为元素引用而非迭代器指针。对于部分容器，暴露引用不要更改其值，避免发生未定义行为。修改值要使用容器接口！</li><li>tips</li><li class="ql-indent-1">右值构造中，A a=getA(); 是将右值的所有成员copy？只对指针move？</li><li class="ql-indent-1">右值构造函数与构造函数中（本身就是为了copy，不可能是copy一份作为参数传入构造函数中），传入的是参数是引用！</li><li class="ql-indent-1">传入形参，若为对象，调用参数为对象，在本地构造局部对象并copy！若为引用，调用参数为<span style="background-color: rgb(230, 0, 0);">对象或对象引用</span>（不能取地址，在形参中使用取地址符默认返回指针！），则函数域中任何对引用的操作都会被间接寻址。（引用是对象，引用没有地址，对引用的所有操作都会被间接寻址）。若形参为指针，则调用参数为地址或指针，在作用域内生成指针对象。对于右值引用，同引用，但注意右值引用本身是左值！对其操作将被间接寻址到临时变量！</li><li class="ql-indent-1">参数重载中无法区别传入的参数是对象还是引用。（正是由于引用是由参数名初始化而非是参数地址初始化（为了区分指针和引用））。同样是引用，通过其是右值还是左值来区分引用类型。</li><li class="ql-indent-1">能否将引用作为参数返回？可以！</li><li class="ql-indent-1">引用是否为对象？不是对象，其虽然能够在类中在构造时/函数形参传入被灵活指向，但其总是在构造时初始化。本质？难道是对符号表的操作？倘若一个函数被重入，符号又如何安排？</li><li class="ql-indent-1">class的内存分布。class地址等于第一个成员的地址。</li><li>return 与函数栈桢。当进入函数体时，该函数所有变量的内存都被分配，包括中间变量与表达式中间变量。若调用函数，则在函数栈桢末尾添加栈桢并分配</li></ul><p><br></p>