<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-b43153c5-bdfb-4114-b005-85f95974cbd6"></attachment><ul><li>定义函数类型指针。定义callback handle的方式</li><li>对于handle这种泛型对象，template是一种很好的泛型实现方式</li><li>Event Handle</li><li>注意，部分程序的编写具有较高的通用性，适应于多个环境，则源于工程实践。</li><li>循环引用问题</li><li class="ql-indent-1">new，或者智能指针创建的引用，倘若存在循环引用（指针指向），则智能指针无法通过引用计数法正确回收内存。若发生循环引用，则要解耦，或者采用weakptr来消除引用。</li><li class="ql-indent-1">释放内存的条件：c++，对象必须被分配内存创建在堆上，当法伤以下情况时考虑是否释放内存，指向内存指针被以任何形式删除时，定义的指针引用被删除，类或容器中存在的引用指针被删除，栈上指向其的指针被删除；python，对象的别名被删除，容器被删除，别名指向其他对象，离开作用域。</li><li class="ql-indent-1">python内存管理方法，python的赋值大量使用引用，尤其是容器对象。python采用引用计数，标记清除，分代回收的策略进行内存管理。</li><li class="ql-indent-1">引用计数：当一个内存对象的被引用计数为0时，即没有任何指针，引用指向该内存对象，则释放该对象。</li><li class="ql-indent-1">标记清除，当释放一个对象时，将该对象所有引用对象计数-1，并将该对象所有引用对象的引用对象计数-1，循环直到遍历一次所有相关对象，对于计数为0的对象，释放。由于该动作会发现所有循环引用的环入口，后续只需根据引用计数法释放即可。但较为占用资源！</li><li class="ql-indent-1">分代回收：内存占用达到回收阀值时，对对象进行一次回收。存活时间越长的对象，则降低回收频率。</li><li class="ql-indent-1">python包的循环引用问题</li><li>面向接口编程</li><li class="ql-indent-1">编程模式，适用于增量开发模式，是一种开发模式，并不一定是生产模式。为了保证程序的开放性，高内聚耦合特性，易于开发维护，但会影响程序的性能。如果要release，榨干性能，需要进行优化。</li><li class="ql-indent-1">我认为，是一种增量概念。</li><li class="ql-indent-1">面对对象编程，核心概念是建模，对象。核心原则为开闭原则和里氏替换原则。建模：根据解决问题，建立对象模型，建立对象架构并梳理对象属性，方法，沟通对象间的关系。对象，一个程序对象，由基类和派生类组成，派生类完成对基类的细化。对象需满足两个条件，开闭原则和里氏替换原则。对象对外开放，需确保开放接口的可靠性和通用性，充分满足外部要求。对内自治，管理好一切并行安全问题，泄露问题，和性能问题</li></ul><p><br></p>