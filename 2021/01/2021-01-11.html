<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-b43153c5-bdfb-4114-b005-85f95974cbd6"></attachment><ul><li>定义函数类型指针。定义callback handle的方式</li><li>对于handle这种泛型对象，template是一种很好的泛型实现方式</li><li>Event Handle</li><li>注意，部分程序的编写具有较高的通用性，适应于多个环境，则源于工程实践。</li><li>循环引用问题</li><li class="ql-indent-1">new，或者智能指针创建的引用，倘若存在循环引用（指针指向），则智能指针无法通过引用计数法正确回收内存。若发生循环引用，则要解耦，或者采用weakptr来消除引用。</li><li class="ql-indent-1">释放内存的条件：c++，对象必须被分配内存创建在堆上，当法伤以下情况时考虑是否释放内存，指向内存指针被以任何形式删除时，定义的指针引用被删除，类或容器中存在的引用指针被删除，栈上指向其的指针被删除；python，对象的别名被删除，容器被删除，别名指向其他对象，离开作用域。</li><li class="ql-indent-1">python内存管理方法，python的赋值大量使用引用，尤其是容器对象。python采用引用计数，标记清除，分代回收的策略进行内存管理。</li><li class="ql-indent-1">引用计数：当一个内存对象的被引用计数为0时，即没有任何指针，引用指向该内存对象，则释放该对象。</li><li class="ql-indent-1">标记清除，当释放一个对象时，将该对象所有引用对象计数-1，并将该对象所有引用对象的引用对象计数-1，循环直到遍历一次所有相关对象，对于计数为0的对象，释放。由于该动作会发现所有循环引用的环入口，后续只需根据引用计数法释放即可。但较为占用资源！</li><li class="ql-indent-1">分代回收：内存占用达到回收阀值时，对对象进行一次回收。存活时间越长的对象，则降低回收频率。</li><li class="ql-indent-1">python包的循环引用问题</li><li>面向接口编程</li><li class="ql-indent-1">编程模式，适用于增量开发模式，是一种开发模式，并不一定是生产模式。为了保证程序的开放性，高内聚耦合特性，易于开发维护，但会影响程序的性能。如果要release，榨干性能，需要进行优化。</li><li class="ql-indent-1">我认为，是一种增量概念。</li><li class="ql-indent-1">面对对象编程，核心概念是建模，对象。核心原则为开闭原则和里氏替换原则。建模：根据解决问题，建立对象模型，建立对象架构并梳理对象属性，方法，沟通对象间的关系。对象，一个程序对象，由基类和派生类组成，派生类完成对基类的细化。对象需满足两个条件，开闭原则和里氏替换原则。对象对外开放，需确保开放接口的可靠性和通用性，充分满足外部要求。对内自治，管理好一切并行安全问题，泄露溢出问题，和性能问题。总而言之，需要易用，可靠。设计好的类，易于实现以上特性。</li><li class="ql-indent-1">面对接口编程，考虑到面对对象编程是基于既有业务逻辑，进行抽象、归并、结构所建立的模型，在开发存在的主要问题是出现无法预料的增量，此时会对程序架构造成毁灭性的打击。因此，需要积极地外包抽象接口，来稳定程序模块之间的耦合（在无法降低耦合的前提下）。同时，抽象接口的实现在满足接口要求的情况下，有一定的实现自由，有开发裕度。基于此理念，按照需求包装接口，同时要具备一定的抽象能力，能够高度抽象对象实现。</li><li class="ql-indent-1">程序架构结构如下，各层级根据需要“长枝”</li><li class="ql-indent-1">抽象接口：根据程序架构抽象出的关联组件间的稳定的“接口”</li><li class="ql-indent-2">实现基类：根据架构实现的对象，“合并”了对象的共同特征，向上依赖接口，向下实现多态</li><li class="ql-indent-3">派生类：由基类派生出的业务细类</li><li class="ql-indent-4">具体实现：依据接口自由实现具体业务</li><li>xmemcpy</li><li>综合debug，善用print debug方式。高级gdb debug。代码debug。log debug法。</li><li>assert（）</li></ul><p><br></p>