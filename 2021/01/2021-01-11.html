<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-b43153c5-bdfb-4114-b005-85f95974cbd6"></attachment><ul><li>定义函数类型指针。定义callback handle的方式</li><li>对于handle这种泛型对象，template是一种很好的泛型实现方式</li><li>Event Handle</li><li>注意，部分程序的编写具有较高的通用性，适应于多个环境，则源于工程实践。</li><li>循环引用问题</li><li class="ql-indent-1">new，或者智能指针创建的引用，倘若存在循环引用（指针指向），则智能指针无法通过引用计数法正确回收内存。若发生循环引用，则要解耦，或者采用weakptr来消除引用。</li><li class="ql-indent-1">释放内存的条件：c++，对象必须被分配内存创建在堆上，当法伤以下情况时考虑是否释放内存，指向内存指针被以任何形式删除时，定义的指针引用被删除，类或容器中存在的引用指针被删除，栈上指向其的指针被删除；python，对象的别名被删除，容器被删除，别名指向其他对象，离开作用域。</li><li class="ql-indent-1">python内存管理方法，python的赋值大量使用引用，尤其是容器对象。python采用引用计数，标记清除，分代回收的策略进行内存管理。</li><li class="ql-indent-1">引用计数：当一个内存对象的被引用计数为0时，即没有任何指针，引用指向该内存对象，则释放该对象。</li><li class="ql-indent-1">标记清除，当释放一个对象时，将该对象所有引用对象计数-1，并将该对象所有引用对象的引用对象计数-1，循环直到遍历一次所有相关对象，对于计数为0的对象，释放。由于该动作会发现所有循环引用的环入口，后续只需根据引用计数法释放即可。但较为占用资源！</li><li class="ql-indent-1">分代回收：内存占用达到回收阀值时，对对象进行一次回收。存活时间越长的对象，则降低回收频率。</li><li>python包的循环引用问题</li></ul><p><br></p>