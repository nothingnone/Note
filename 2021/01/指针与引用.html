<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-96c5064a-6def-479b-8155-ae18a9878f99"></attachment><ul><li>指针创建两个对象，指针与指针值。指针固定，而指针值可变。</li><li>指针的初始化必须使用地址，而引用的初始化不必。引用在编译时会加载到符号表上，可看做别名，创建时必须初始化，且程序运行时不可变，引用的地址为引用对象的地址。而指针的地址为指针的地址，值为指针指向的地址。任何对引用的操作都会间接寻址，因此指针的所有操作，如++，*，&amp;，都会被加到引用对象上，因此要注意！</li><li>当采用指针和引用，向函数传递形参时。运行到函数内部时，指针则在栈上创建局部指针，指针指向的值为地址；引用则创建局部引用，任何对其的操作都会被间接寻址。考虑到引用的安全性，不必对其进行检查，可提高程序的运行效率。</li><li>指向常量的常指针 int const <em> const p = </em>addr(&amp;v,new v, malloc a), const<em> </em>int * const p = addr.</li><li>typedef 问题，typedef string* pstring; string s; const pstring p1 = &amp;s; X pstring const p2 = &amp;s; yes 前者声明了一个常量指针，指向了指针，那么指针的值无法变动。后者声明了常指针指向指针地址，指针的值可以变动但地址不会变动。注意地址的嵌套问题!</li><li>操作符重载的问题。比如对[]操作符进行重载，就要考虑重载返回的值究竟时引用还是指针。</li><li>const int &amp;ir 常量引用，对于临时变量，必须使用常量引用，地址值&amp;v是不可寻址的。</li></ul><p><br></p>