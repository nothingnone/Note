<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-b69d7cfd-5aa0-4e03-a36b-30b755db60bd"></attachment><ul><li>linux epoll 机制 异步机制</li><li>linux::signal 机制</li><li>&lt;&lt;, &gt;&gt; 重载</li><li>float精度不够，double很好而且计算精度高，甚至速度比float快。double two word，64位。而double不存在问题。同时浮点数计算很麻烦。float范围是正负2^128，正负2^(-127)，而double范围是2^1024~2^(-1023)，而精度上float保证6位，double保证15位。</li><li>float与double详解：带符号前面有一位符号位。float指数8位，double指数11位,指数前有一位符号位，因此指数范围为127，1023。float尾数23位，double尾数52位，前面没有符号位。用科学计数法表示，整数为默认为1。因此范围是+(max=2-(1/2)^23=2-0)<em>(2)^(+max=(2^7)-1=127)=+2^128 到 +(min=1+(1/2)^23=1+0)</em>(2)^(-127)=+2^(-127)。而精度较为固定，为2^23=8388608，精度7位，能保证6位。同理double的范围是2^1024到2^(-1023)，精度为2^52=4503599627370496即16为，保证15位。</li><li>若要计算，优先选择double。如果传输数据，优先double。</li><li>注意浮点运算中的精度问题！unsigned int类型的数值溢出会导致取模?未必！为signed行为会导致未定义，其会破坏符号机制。那浮点数值的溢出呢？会输出inf。</li><li>如果signed 和 unsigned一块运算，则将signed转换为unsigned，极其危险！</li><li>011表示8进制，注意！</li></ul><p><br></p>